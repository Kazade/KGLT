#!/usr/bin/env python3

import os
import itertools
import argparse
import getpass
import pwd
import shutil
import sys
import subprocess
from subprocess import Popen
import platform
import json
import tempfile
from io import BytesIO
from zipfile import ZipFile

from urllib.request import urlopen

PLACEHOLDER = "__project_name__"

THIS_DIR = os.path.dirname(__file__)

POTENTIAL_TEMPLATE_DIRS = [
    THIS_DIR,
    "/usr/local/share/simulant",
    "/usr/share/simulant"
]

POTENTIAL_TOOLCHAIN_DIRS = [
    os.path.join(THIS_DIR, "toolchains"),
    os.path.join(os.path.dirname(THIS_DIR), "toolchains"),
    "/usr/local/share/simulant/toolchains",
    "/usr/share/simulant/toolchains"
]


def _check_tool(name):
    try:
        subprocess.check_output(["which", name])
        return True
    except subprocess.CalledProcessError:
        print("{} is not installed, or not found".format(name))
        return False


def _locate_toolchain_file(name):
    for path in POTENTIAL_TOOLCHAIN_DIRS:
        path = os.path.abspath(path)

        toolchain = os.path.join(path, "{}.cmake".format(name))
        if os.path.exists(toolchain):
            return toolchain


def _locate_template_folder():
    for path in POTENTIAL_TEMPLATE_DIRS:
        path = os.path.abspath(path)

        template = os.path.join(path, "template")

        if os.path.exists(template):
            return template


def _rename_files_and_directories(search, replacement, directory):
    " Recursively replaces 'search' in folder and filenames with 'replacement' "
    for root, subdirs, files in os.walk(directory):
        for subdir in subdirs:
            if PLACEHOLDER in subdir:
                path = os.path.join(root, subdir)
                dest = os.path.join(root, subdir.replace(PLACEHOLDER, replacement))
                shutil.move(path, dest)

        for file in files:
            if PLACEHOLDER in file:
                path = os.path.join(root, file)
                dest = os.path.join(root, file.replace(PLACEHOLDER, replacement))
                shutil.move(path, dest)


def _search_replace(search, replacement, directory, extensions=[".cpp", ".h", ".md", ".json", ".txt"]):
    "Recursively search replace text in files that match the extensions"
    for root, subdirs, files in os.walk(directory):
        for file in files:
            if os.path.splitext(file)[-1] in extensions:
                path = os.path.join(root, file)

                with open(path, "r") as f:
                    s = f.read()

                s = s.replace(search, replacement)

                with open(path, "w") as f:
                    f.write(s)


def _check_project():
    if not os.path.exists("simulant.json"):
        print("ERROR: Unable to find simulant.json")
        return False

    return True


class BuildOutput:
    build_dir = None


def _calculate_platform(platform_name):
    if platform_name == "native":
        return platform.system().lower()
    else:
        return platform_name.lower()


def _calculate_build_dir(args):
    build_type = "release" if args.release else "debug"

    arch = args.platform
    if args.platform == "native":
        build_dir = "build/{}/{}-{}".format(
            build_type,
            platform.system().lower(),
            platform.machine()
        )
    else:
        build_dir = "build/{}/{}".format(build_type, arch)

    return build_dir


def build(args, build_output=None):
    if not _check_project():
        return 1

    if not _check_tool("cmake"):
        return 2

    project_dir = os.getcwd()
    platform = _calculate_platform(args.platform)
    arch = args.platform
    build_dir = _calculate_build_dir(args)
    build_type = "release" if args.release else "debug"

    if not os.path.exists(build_dir):
        os.makedirs(build_dir)

    if platform == "dreamcast":
        build_type = "release"
        project_dir = "/simulant-project"
        args.use_global_simulant = False

    cmake_params = ""
    if build_type == "release":
        cmake_params += " -DCMAKE_BUILD_TYPE=Release"

    if not args.use_global_simulant:
        cmake_params += " -DSIMULANT_INCLUDE_FOLDER={}".format(
            os.path.join(project_dir, "libraries", platform, "include")
        )

        cmake_params += " -DSIMULANT_LIBRARY_FOLDER={}".format(
            os.path.join(project_dir, "libraries", platform, "lib", build_type)
        )

    if arch == "dreamcast":
        if not _check_tool("docker"):
            return 3

        toolchain = _locate_toolchain_file("Dreamcast")
        if not toolchain:
            print("Unable to find the Dreamcast toolchain file")
            return 4

        volume_mount = "{}:/simulant-project:Z".format(os.path.abspath("."))
        container_name = "simulant-dc-build"
        container_build_dir = os.path.join("/simulant-project", build_dir)
        build_dir = os.getcwd()

        cmake_params += " -DCMAKE_TOOLCHAIN_FILE={}".format(
            os.path.join("/simulant-project", "libraries", "Dreamcast.cmake")
        )

        # Start docker if neccesary and forcibly remove any existing build container
        commands = [
            "sudo service docker start",
            "sudo docker rm {} -f".format(container_name)
        ]

        for cmd in commands:
            subprocess.call(cmd.split())

        run_command = "sudo docker run -it -d --name={} -v {} --workdir={} kazade/dreamcast-sdk bash --login".format(container_name, volume_mount, container_build_dir)
        subprocess.check_call(run_command, shell=True)

        cmake_command = 'sudo docker exec -it {} /bin/bash -c "source /etc/bash.bashrc; cmake {} ../../.. && make"'.format(
            container_name, cmake_params
        )
        print(cmake_command)
        return subprocess.call(cmake_command, shell=True)

    elif arch == "windows" and platform.system() == "Linux":
        # We support cross-compiling from Linux to Windows using mingw64
        commands = [
            "mingw64-cmake" + cmake_params,
            "make"
        ]

        commands[0] += " ../../.."
        commands = [cmd.split() for cmd in commands]

    else:
        commands = [
            "cmake" + cmake_params,
            "make"
        ]

        commands[0] += " ../../.."
        commands = [cmd.split() for cmd in commands]

    for cmd in commands:
        print(cmd)
        subprocess.check_call(cmd, cwd=build_dir)

    if build_output:
        build_output.build_dir = build_dir

    return 0


def start(args):
    " Start a Simulant project with a template "

    if "/" in args.project:
        # FIXME: [a-zA-Z0-9_-]+
        print("Project name must not contain slashes")

    template_folder = _locate_template_folder()

    if not os.path.exists(template_folder):
        print("Error: Unable to locate Simulant template")
        return 1

    target_folder = os.path.join(os.path.abspath(args.target), args.project)

    if os.path.exists(target_folder) and not args.force:
        result = input("The target folder already exists and will be replaced, this cannot be undone. Continue? [y/N] ")
        if result.lower() != "y":
            return 0
        else:
            # Remove the directory before replacing it
            shutil.rmtree(target_folder)
    elif os.path.exists(target_folder) and args.force:
        # If we are forcing this, then just remove the folder without asking!
        shutil.rmtree(target_folder)

    shutil.copytree(template_folder, target_folder)

    # Rename any files that have the project name in them
    _rename_files_and_directories("__project_name__", args.project.replace(" ", "_").lower(), target_folder)

    # Replace the project name throughout
    _search_replace("__project_name__", args.project, target_folder)

    # These two replace with project_name or PROJECT_NAME respectively
    _search_replace("__project_name_lower__", args.project.lower().replace(" ", "_"), target_folder)
    _search_replace("__project_name_upper__", args.project.upper().replace(" ", "_"), target_folder)

    pascal_name = args.project.replace("-", " ").title().replace(" ", "")

    # Replace with ProjectName
    _search_replace("__project_name_pascal__", pascal_name, target_folder)

    # Change to the project directory
    os.chdir(target_folder)

    # Run the update command to get the latest simulant libraries
    update(args)

    print("\n\nProject successfully created. Remember to edit simulant.json before packaging!")

    return 0


def _generate_flatpak(args, build_dir):
    META_TEMPLATE = """
[Application]
name={package}
command={executable}
runtime=org.freedesktop.Platform/x86_64/1.6

[Context]
shared=network;
sockets=x11;wayland;pulseaudio;
devices=dri;
"""

    DESKTOP_TEMPLATE = """
[Desktop Entry]
Name={name}
Exec={executable}
Comment={description}
"""

    APPDATA_TEMPLATE = """
<?xml version="1.0" encoding="UTF-8" ?>
<component type="desktop">
    <id>{package}.desktop</id>
    <name>{name}</name>
    <description>{description}</description>
</component>
    """

    with open("simulant.json") as f:
        data = json.loads(f.read())

    package_dir = os.path.join(build_dir, "package")

    if os.path.exists(package_dir):
        shutil.rmtree(package_dir)

    files_dir = os.path.join(package_dir, "files")
    binary_dir = os.path.join(package_dir, "files/bin")
    export_dir = os.path.join(package_dir, "export")
    desktop_file = os.path.join(export_dir, "applications", "{}.desktop".format(
        data["package"]
    ))
    appdata_file = os.path.join(export_dir, "appdata", "{}.appdata.xml".format(data["name"]))

    os.makedirs(binary_dir)
    os.makedirs(export_dir)
    os.makedirs(os.path.dirname(appdata_file))
    os.makedirs(os.path.dirname(desktop_file))

    with open(desktop_file, "w") as fout:
        fout.write(DESKTOP_TEMPLATE.format(**data))

    with open(appdata_file, "w") as fout:
        fout.write(APPDATA_TEMPLATE.format(**data).lstrip())

    project = data["executable"]
    executable = os.path.join(build_dir, project)
    assets = os.path.join(build_dir, "assets")

    shutil.copy(executable, binary_dir)
    shutil.copytree(assets, os.path.join(files_dir, "assets"))

    with open(os.path.join(package_dir, "metadata"), "w") as f:
        f.write(META_TEMPLATE.format(**data))

    temp_repo = os.path.join(build_dir, "repo")
    try:
        if os.path.exists(temp_repo):
            shutil.rmtree(temp_repo)

        command = "flatpak build-export {} {}".format(
            temp_repo, package_dir
        )

        subprocess.check_call(command.split())

        command = "flatpak build-bundle {} {}.flatpak {}".format(
            temp_repo,
            executable,
            data["package"]
        )

        subprocess.check_call(command.split())
    finally:
        if os.path.exists(temp_repo):
            shutil.rmtree(temp_repo)


def _run_docker_command(command, use_existing=False):
    pass


def _generate_ip_bin(dest):
    pass


def _scramble_binary(binary, dest):
    bin_file = os.path.splitext(binary)[0] + ".bin"
    commands = [
        "sh-elf-objcopy -R .stack -O binary {} {}".format(binary, bin_file),
        "scramble {} {}".format(bin_file, dest)
    ]

    for command in commands:
        _run_docker_command(command)


def _generate_dc_cdi(args, build_dir):
    output_dir = "/tmp/dcbuild" # FIXME: tempdir
    if os.path.exists(output_dir):
        shutil.rmtree(output_dir)

    os.makedirs(output_dir)

    # Search for the .elf binary in the build directory
    binary = (x for x in os.listdir(build_dir) if x.endswith(".elf")).next()

    # Copy assets to the output directory
    shutil.copy("assets", os.path.join(output_dir, "assets"))

    _generate_ip_bin(os.path.join(output_dir, "IP.BIN"))
    _scramble_binary(
        os.path.join(build_dir, binary), os.path.join(output_dir, "1ST_READ.BIN")
    )


def package(args):
    if not _check_project():
        return 1

    plat = args.platform
    if plat == "native":
        if platform.system() == "Linux":
            plat = "linux"
        elif platform.system() == "Windows":
            plat = "windows"
        else:
            plat = "osx"

    if plat == "dreamcast":
        class Args:
            release = True
            platform = "dreamcast"

        # Compile to .elf using docker
        output = BuildOutput()
        build(Args(), output)

        _generate_dc_cdi(args, output.build_dir)

    if plat == "linux":
        class Args:
            release = True
            platform = "native"
            use_global_simulant = False

        output = BuildOutput()

        build(Args(), output) # Trigger a release build
        _generate_flatpak(args, output.build_dir)
    else:
        print("Packaging for {} is not currently supported".format(plat))
        return 1

    return 0


def test(args):
    return 0


def update(args):
    """
        Downloads the latest binaries from Google Cloud Storage, will download the debug + release
        binaries for the current platform, and also any cross-buildable versions (e.g. Dreamcast, Windows-on-Linux)
    """
    if not _check_project():
        return 1

    DOWNLOAD_ROOT = "https://storage.googleapis.com/staging.simulant-engine.appspot.com"

    system = platform.system()

    to_download = []

    if system == "Linux":
        to_download.extend([
            ("linux", "simulant-linux-release.zip"),
            ("linux", "simulant-linux-debug.zip")
        ])
    elif system == "Darwin":
        to_download.extend([
            ("osx", "simulant-osx-release.zip"),
            ("osx", "simulant-osx-debug.zip")
        ])
    else:
        print("Unsupported platform: {}".format(system))

    if not args.native_only:
        # Download cross-compile toolchains unless explicitly told not to
        to_download.append(("dreamcast", "simulant-dreamcast-release.zip"))

    print("Downloading Simulant dependencies", end='', flush=True)

    for i, (folder, download) in enumerate(to_download):
        print(".", end='', flush=True)

        target_dir = os.path.join("libraries", folder)

        url = "{}/{}".format(DOWNLOAD_ROOT, download)
        url = urlopen(url)

        with ZipFile(BytesIO(url.read())) as zipfile:
            tempdir = tempfile.mkdtemp()
            zipfile.extractall(path=tempdir)

            for folder in ("include", "lib"):
                target_subfolder = os.path.join(target_dir, folder)

                source = os.path.join(tempdir, os.path.splitext(download)[0], folder)

                for root, dirs, files in os.walk(source):
                    for file in files:
                        paths = (
                            os.path.join(root, file),
                            os.path.join(target_subfolder, root[len(source) + 1:], file)
                        )

                        dest_dir = os.path.dirname(paths[1])
                        if not os.path.exists(dest_dir):
                            os.makedirs(dest_dir)

                        shutil.copy(paths[0], paths[1])

                shutil.rmtree(source)
    print("\nDone!\n")

def run(args):
    if not _check_project():
        return 1

    if args.rebuild:
        build(args) # Trigger a build

    build_dir = _calculate_build_dir(args)

    with open("simulant.json") as f:
        data = json.loads(f.read())
        executable = data["executable"]

    subprocess.run(
        [os.path.abspath(os.path.join(build_dir, executable))],
        cwd=build_dir
    )

    return 0


COMMAND_LOOKUP = {
    'start': start,
    'build': build,
    'test': test,
    'package': package,
    'run': run,
    'update': update
}


def main():
    parser = argparse.ArgumentParser(description="Simulant Tool")
    subs = parser.add_subparsers(dest="subcommand")

    build = subs.add_parser("build", help="Build your project")
    build.add_argument("platform", default="native", nargs="?", choices=[
        "native", "dreamcast", "android", "windows"
    ])
    build.add_argument("--rebuild", default=False, action="store_true")
    build.add_argument("--release", default=False, action="store_true")
    build.add_argument(
        "--use-global-simulant", default=False, action="store_true",
        help="When specified, search the system for the Simulant includes and libraries"
    )

    package = subs.add_parser("package", help="Package your project for a particular platform")
    package.add_argument("platform", default="native", nargs="?", choices=[
        "native", "dreamcast", "android", "windows"
    ])

    start = subs.add_parser("start", help="Start a new Simulant project from a template")
    start.add_argument("project", action="store", type=str)
    start.add_argument("target", default=".", nargs="?", type=str)
    start.add_argument("-f", dest="force", action="store_true")
    start.add_argument("--native-only", action="store_true", default=False)

    test = subs.add_parser("test", help="Test your Simulant project")

    run = subs.add_parser("run", help="Run your application")
    run.add_argument("platform", default="native", nargs="?", choices=[
        "native", "dreamcast", "android", "windows"
    ])
    run.add_argument("--rebuild", default=False, action="store_true")
    run.add_argument("--release", default=False, action="store_true")

    update = subs.add_parser("update", help="Update Simulant library")
    update.add_argument("--native-only", action="store_true", default=False)

    opts = parser.parse_args()

    return COMMAND_LOOKUP[opts.subcommand](opts)


if __name__ == '__main__':
    sys.exit(main())
