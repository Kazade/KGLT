diff -ruN newlib-2.4.0/newlib/configure.host newlib-2.4.0-kos/newlib/configure.host
--- newlib-2.4.0/newlib/configure.host	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/configure.host	2019-06-11 11:19:48.804253881 +0100
@@ -267,6 +267,7 @@
 	;;
   sh | sh64)
 	machine_dir=sh
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED -DMALLOC_PROVIDED -DABORT_PROVIDED -DHAVE_FCNTL -ffunction-sections -fdata-sections"
 	;;
   sparc*)
 	machine_dir=sparc
diff -ruN newlib-2.4.0/newlib/configure.host.orig newlib-2.4.0-kos/newlib/configure.host.orig
--- newlib-2.4.0/newlib/configure.host.orig	1970-01-01 01:00:00.000000000 +0100
+++ newlib-2.4.0-kos/newlib/configure.host.orig	2019-06-11 11:19:48.804253881 +0100
@@ -0,0 +1,892 @@
+# configure.host
+
+# This shell script handles all host based configuration for newlib.
+# It sets various shell variables based on the the host and the
+# configuration options.  You can modify this shell script without
+# needing to rerun autoconf.
+
+# This shell script should be invoked as
+#   . configure.host
+# If it encounters an error, it will exit with a message.
+
+# FIXME: This script is too complicated.  It does things in too many
+# different ways.  This was taken from the old Cygnus configure script
+# with only minor changes.  It should be cleaned up.
+
+# FIXME: The general approach of picking and choosing which
+# directories to configure, other than machine_dir and sys_dir, is
+# potentially confusing.
+
+# It uses the following shell variables:
+#   host		The configuration host
+#   host_cpu		The configuration host CPU
+#   newlib_mb		--enable-newlib-mb ("yes", "no")
+#   target_optspace	--enable-target-optspace ("yes", "no", "")
+#   newlib_multithread	--enable-newlib-multithread ("yes", "no", "yes")
+#   newlib_elix_level	--enable-newlib-elix-level ("1","2","3","4") ("4")
+#   newlib_io_c99_formats --enable-newlib-io-c99-formats ("yes", "no", "")
+#   newlib_io_long_long --enable-newlib-io-long-long ("yes", "no", "")
+#   newlib_io_long_double --enable-newlib-io-long-double ("yes", "no", "")
+
+# It sets the following shell variables:
+#   newlib_cflags	Special CFLAGS to use when building
+#   machine_dir		Subdirectory of libc/machine to configure
+#   sys_dir		Subdirectory of libc/sys to configure
+#   have_sys_mach_dir	Is there a machine subdirectory in sys subdirectory
+#   posix_dir		"posix" to build libc/posix, "" otherwise
+#   signal_dir		"signal" to build libc/signal, "" otherwise
+#   stdio64_dir		"stdio64" to build libc/stdio64, "" otherwise
+#   syscall_dir		"syscalls" to build libc/syscalls, "" otherwise
+#   unix_dir		"unix" to build libc/unix, "" otherwise
+#   use_libtool         flag: use libtool to build newlib?
+#   aext                library extension - needed for libtool support
+#   oext                object file extension - needed for libtool support
+#   lpfx		library object prefix - generated when no libtool
+#   crt1                name of crt1 object if one is provided
+#   crt1_dir            directory where crt1 object is found
+#   have_crt0		"yes"/"no" if crt0 is/isn't provided.
+#			"" if crt0 is provided when sys_dir is set
+#   noinclude		list of include files to not install
+
+newlib_cflags=
+libm_machine_dir=
+machine_dir=
+sys_dir=
+posix_dir=
+signal_dir=signal
+stdio_dir=stdio
+stdio64_dir=
+xdr_dir=
+syscall_dir=
+unix_dir=
+noinclude=
+mach_add_setjmp=
+crt1=
+crt1_dir=
+have_crt0=
+use_libtool=no
+have_sys_mach_dir=no
+default_newlib_io_c99_formats=no
+default_newlib_io_long_long=no
+default_newlib_io_long_double=no
+default_newlib_io_pos_args=no
+default_newlib_atexit_dynamic_alloc=yes
+default_newlib_nano_malloc=no
+aext=a
+oext=o
+lpfx="lib_a-"
+
+case "${target_optspace}:${host}" in
+  yes:*)
+    newlib_cflags="${newlib_cflags} -Os"
+    ;;
+  :m32r-* | :d10v-* | :d30v-* | :avr-* | :m32c-* | :msp430*-* | :nds32* | :rl78-* )
+    newlib_cflags="${newlib_cflags} -Os"
+    ;;
+  no:* | :*)
+    ;;
+esac
+
+# Get the source directories to use for the CPU type.
+# machine_dir should supply CPU dependent routines, such as setjmp.
+# newlib_cflags is passed to gcc when compiling.
+# THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
+
+case "${host_cpu}" in
+  a29k)
+	machine_dir=a29k
+	;;
+  aarch64*)
+	machine_dir=aarch64
+	libm_machine_dir=aarch64
+	;;
+  arc*)
+	machine_dir=arc
+	;;
+  arm*)
+	machine_dir=arm
+	libm_machine_dir=arm
+	;;
+  avr*)
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -mcall-prologues"
+	;;
+  bfin)
+	machine_dir=bfin
+	;;
+  cr16*)
+	machine_dir=cr16
+       ;;
+  cris | crisv32)
+	machine_dir=cris
+	;;
+  crx*)
+	machine_dir=crx
+	;;
+  d10v*)
+	machine_dir=d10v
+	;;
+  d30v*)
+	machine_dir=d30v
+	;;
+  epiphany)
+	machine_dir=epiphany
+	;;
+  fido)
+	machine_dir=m68k
+	newlib_cflags="${newlib_cflags} -DCOMPACT_CTYPE"
+	;;
+  fr30)
+	machine_dir=fr30
+	;;
+  frv)
+	machine_dir=frv
+        ;;
+  ft32*)
+        machine_dir=ft32
+        newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED"
+        ;;
+  h8300)
+	machine_dir=h8300
+	;;
+  h8500)
+	machine_dir=h8500
+	;;
+  hppa*)
+	machine_dir=hppa
+	;;
+  i960)
+	machine_dir=i960
+	;;
+  i[34567]86)
+	# Don't use for these since they provide their own setjmp.
+	case ${host} in
+	*-*-sco* | *-*-cygwin*) 
+		libm_machine_dir=i386
+		machine_dir=i386
+		;;
+	*) 
+		libm_machine_dir=i386
+		machine_dir=i386
+		mach_add_setjmp=true
+		;;
+	esac
+	;;
+  ia64*)
+	;;
+  iq2000)
+	machine_dir=iq2000
+	;;
+  lm32)
+	machine_dir=lm32
+	;;
+  m32c)
+	machine_dir=m32c	
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+	;;
+
+  m32r*)
+	machine_dir=m32r
+	;;
+
+  m68hc11|m6811|m68hc12|m6812)
+	machine_dir=m68hc11
+	newlib_cflags="-DPREFER_SIZE_OVER_SPEED -Os -mrelax"
+	CFLAGS="-g -Os"
+	;;
+  
+  m68*)
+	machine_dir=m68k
+	newlib_cflags="${newlib_cflags} -DCOMPACT_CTYPE"
+	;;
+  m88k)
+	machine_dir=m88k
+	newlib_cflags="${newlib_cflags} -m88000"
+	;;
+  m88110)
+	machine_dir=m88k
+	newlib_cflags="${newlib_cflags} -m88110"
+	;;
+  mcore)
+	;;
+  microblaze*)
+	machine_dir=microblaze
+	;;
+  mep)
+	machine_dir=mep
+	;;
+  mips*)
+	machine_dir=mips
+	;;
+  mmix)
+	;;
+  mn10200)
+	machine_dir=mn10200
+	;;
+  mn10300)
+	default_newlib_io_long_long="yes"
+	machine_dir=mn10300
+	;;
+  moxie)
+	machine_dir=moxie
+        ;;
+  msp430*)
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	newlib_cflags="${newlib_cflags} -mOs "
+	newlib_cflags="${newlib_cflags} -mhwmult=none "
+	machine_dir=msp430
+	default_newlib_nano_malloc="yes"
+	;;
+  mt*)
+	machine_dir=mt
+	;;
+  nds32*)
+	machine_dir=nds32
+	libm_machine_dir=nds32
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections"
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME"
+	;;
+  nios2*)
+	machine_dir=nios2
+	;;
+  or1k*|or1knd*)
+	machine_dir=or1k
+	;;
+  powerpc*)
+	machine_dir=powerpc
+	;;
+  rl78)
+	machine_dir=rl78
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	;;
+  rx)
+	machine_dir=rx
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	;;
+  sh | sh64)
+	machine_dir=sh
+	;;
+  sparc*)
+	machine_dir=sparc
+	# FIXME: Might wish to make MALLOC_ALIGNMENT more generic.
+	newlib_cflags="${newlib_cflags} -DMALLOC_ALIGNMENT=8"
+	;;
+  tic4x|c4x)
+	machine_dir=tic4x
+	;;
+  tic6x)
+	machine_dir=tic6x
+	;;
+  tic80*)
+	machine_dir=tic80
+	;;
+  v70)
+	;;
+  v810)
+	;;
+  v850*)
+	machine_dir=v850
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED "
+	;;
+  visium)
+	machine_dir=visium
+	;;
+  w65*)
+	machine_dir=w65
+	;;
+  x86_64)
+	machine_dir=x86_64
+	;;
+  xc16x*)
+        machine_dir=xc16x
+        ;;
+  xstormy16)
+	machine_dir=xstormy16
+	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED"
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED"
+        ;;
+  z8k)
+	machine_dir=z8k
+	;;
+  spu)
+	stdio_dir=
+	libm_machine_dir=spu
+	machine_dir=spu
+	newlib_cflags="${newlib_cflags} -D_POSIX_MODE"
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	;;
+  *)
+	echo '***' "Newlib does not support CPU ${host_cpu}" 1>&2
+	exit 1
+	;;
+esac
+
+# Disable thread support if requested.
+
+if [ "${newlib_multithread}" = "no" ] ; then
+	newlib_cflags="${newlib_cflags} -D__SINGLE_THREAD__"
+fi
+
+# Disable syscall support if requested.
+
+if [ "${newlib_may_supply_syscalls}" = "no" ] ; then
+        newlib_cflags="${newlib_cflags} -D__NO_SYSCALLS__"
+fi
+
+# Enable multibyte support if requested or it is defaulted
+# for target.
+
+if [ "x${newlib_mb}" = "x" ]; then
+	case "${host}" in
+  	  i[34567]86-pc-linux-*|*-*-cygwin*)
+		newlib_mb=yes
+	  	;;
+	esac
+fi
+
+# Disable printf/scanf floating-point support if requested.
+
+if [ "${newlib_io_float}" = "no" ] ; then
+	newlib_cflags="${newlib_cflags} -DNO_FLOATING_POINT"
+fi
+
+# Verify if shared newlib support is allowed and set appropriate variables
+# We don't want to use libtool for platforms that we are not going to
+# support shared libraries.  This is because it adds executable tests which
+# we don't want for most embedded platforms.
+case "${host}" in
+  i[34567]86-pc-linux-*)
+    use_libtool=yes
+    have_sys_mach_dir=yes
+    stdio64_dir=stdio64
+    oext=lo
+    lpfx=
+    aext=la ;;
+  *) ;; #shared library not supported for ${host}
+esac
+
+# Get the source directories to use for the host.  unix_dir is set
+# to unix to get some standard Unix routines.  posix_dir is set to get some
+# standard Posix routines.  sys_dir should supply system dependent routines
+# including crt0.
+# THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
+
+case "${host}" in
+  *-*-cygwin*)
+	posix_dir=posix
+	stdio64_dir=stdio64
+	xdr_dir=xdr
+	;;
+  *-*-netware*)
+	signal_dir=
+	sys_dir=netware
+	;;
+  *-*-rtems*)			# generic RTEMS support
+	sys_dir=rtems
+	posix_dir=posix
+	unix_dir=unix
+	;;
+  *-*-tirtos*)
+	sys_dir=tirtos
+	have_crt0="no"
+	;;
+  a29k-*-*)
+	sys_dir=a29khif
+	signal_dir=
+	;;
+  arm*-*-*)
+	sys_dir=arm
+	if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
+	  have_crt0="no"
+	fi
+	;;
+  bfin-*-*)
+	sys_dir=
+	;;
+  cr16-*-*)
+	sys_dir=
+	;;
+  crx*)
+	sys_dir=
+	;;
+  d10v*)
+	sys_dir=d10v
+	;;
+  d30v*)
+	sys_dir=
+	;;
+  epiphany-*-*)
+	sys_dir=epiphany
+	# crt0 is provided by libgloss.
+	have_crt0="no"
+	;;
+  frv*)
+        sys_dir=
+        ;;
+  ft32*)
+        sys_dir=
+        ;;
+  h8300-*-hms*)
+	sys_dir=h8300hms
+	;;
+  h8300-*-elf*)
+	sys_dir=h8300hms
+	;;
+  h8300-*-coff*)
+	sys_dir=h8300hms
+	;;
+  h8300-*-xray*)
+	sys_dir=h8300xray
+	;;
+  h8500-*-hms*)
+	sys_dir=h8500hms
+	;;
+  h8500-*-elf*)
+	sys_dir=h8500hms
+	;;
+  i[34567]86-*-rdos*)
+	sys_dir=rdos
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	newlib_cflags="${newlib_cflags} -D_I386MACH_DISABLE_HW_INTERRUPTS"
+	;;
+  i[34567]86-*-sco*)
+	sys_dir=sysvi386
+	unix_dir=unix
+	;;
+  i[34567]86-pc-linux-*)
+	sys_dir=linux
+	unix_dir=unix
+	posix_dir=posix
+	crt1=crt1.o
+	crt1_dir=libc/sys/${sys_dir}	
+	gcc_dir=`gcc -print-search-dirs | awk '/^install:/{print $2}'`
+	default_newlib_io_c99_formats="yes"
+	default_newlib_io_long_double="yes"
+	default_newlib_io_long_long="yes"
+	default_newlib_io_pos_args="yes"
+	#newlib_cflags="${newlib_cflags} -Werror" # DEBUGGING ONLY;BREAKS BUILD
+	newlib_cflags="${newlib_cflags} -Wall"
+	newlib_cflags="${newlib_cflags} -DHAVE_FCNTL"
+	newlib_cflags="${newlib_cflags} -DHAVE_GETOPT"
+	newlib_cflags="${newlib_cflags} -D_NO_POSIX_SPAWN"
+	# --- Required when building a shared library ------------------------
+	newlib_cflags="${newlib_cflags} -fPIC -D_I386MACH_NEED_SOTYPE_FUNCTION"
+	# --- The three lines below are optional ------------------------------
+	##newlib_cflags="${newlib_cflags} -nostdinc"
+	##newlib_cflags="${newlib_cflags} -I`newlib-flags --kernel-dir`/include"
+	##newlib_cflags="${newlib_cflags} -idirafter ${gcc_dir}include"
+	;;
+
+  m68hc11-*-*|m6811-*-*|m6812-*-*|m68hc12-*-*)
+	;;
+
+  m68k-sun-sunos*)
+	unix_dir=unix
+	;;
+  m8*-bug-*)
+	sys_dir=m88kbug
+	;;
+  mep-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  microblaze*-*-*)
+	machine_dir=microblaze
+	;;
+  mips*-dec-*)
+	sys_dir=decstation
+	;;
+  mmix-knuth-mmixware)
+	sys_dir=mmixware
+	;;
+  moxie*)
+        sys_dir=
+        ;;
+  nios2*)
+	sys_dir=
+	;;
+  or1k-*-elf | or1knd-*-elf)
+	sys_dir=or1k
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED "
+	have_crt0="no"
+	;;
+  powerpcle-*-pe)
+	posix_dir=posix
+	;;
+  sh*-*)
+	sys_dir=sh
+	;;
+  sparc-sun-sunos*)
+	sys_dir=sun4
+	unix_dir=unix
+	;;
+  sparc64*)
+	sys_dir=sparc64
+	unix_dir=unix
+	;;
+  spu-*-*)
+	default_newlib_io_long_long="yes"
+	default_newlib_atexit_dynamic_alloc="no"
+	;;
+  tic6x*)
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	have_crt0="no"
+	;;
+  tic80*)
+	sys_dir=tic80
+	;;
+  v70-nec-*)
+	sys_dir=sysvnecv70
+	;;
+  v810-*-*)
+	sys_dir=sysnec810
+	;;
+  v850*-*-*)
+	sys_dir=sysnecv850
+        if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
+          have_crt0="no"
+        fi
+	;;
+  visium-*-*)
+	sys_dir=
+	;;
+  w65-*-*)
+	sys_dir=w65
+	;;
+  z8k-*-coff)
+	sys_dir=z8ksim
+	;;
+esac
+
+# Host specific flag settings -- usually for features that are not
+# general enough or broad enough to be handled above.
+# THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
+
+case "${host}" in
+  *-*-cygwin*)
+	test -z "$cygwin_srcdir" && cygwin_srcdir=`cd ${srcdir}/../winsup/cygwin; pwd`
+	export cygwin_srcdir
+	default_newlib_io_c99_formats="yes"
+	default_newlib_io_long_long="yes"
+	default_newlib_io_long_double="yes"
+	default_newlib_io_pos_args="yes"
+	CC="${CC} -I${cygwin_srcdir}/include"
+	newlib_cflags="${newlib_cflags} -DHAVE_OPENDIR -DHAVE_RENAME -DSIGNAL_PROVIDED -D_COMPILING_NEWLIB -DHAVE_BLKSIZE -DHAVE_FCNTL -DMALLOC_PROVIDED"
+	syscall_dir=syscalls
+	;;
+# RTEMS supplies its own versions of some routines:
+#       malloc()            (reentrant version)
+#       exit()              RTEMS has a "global" reent to flush
+#       signal()/raise()    RTEMS has its own including pthread signals
+#       _XYZ_r()            RTEMS has its own reentrant routines
+#
+#  NOTE: When newlib malloc uses a semaphore, RTEMS will switch to that.
+  *-*-rtems*)
+	default_newlib_io_long_long="yes"
+	default_newlib_io_c99_formats="yes"
+	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB"
+	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DEXIT_PROVIDED -DSIGNAL_PROVIDED -DREENTRANT_SYSCALLS_PROVIDED -DHAVE_NANOSLEEP -DHAVE_BLKSIZE -DHAVE_FCNTL -DHAVE_ASSERT_FUNC"
+        # turn off unsupported items in posix directory 
+	newlib_cflags="${newlib_cflags} -D_NO_GETLOGIN -D_NO_GETPWENT -D_NO_GETUT -D_NO_GETPASS -D_NO_SIGSET -D_NO_WORDEXP -D_NO_POPEN -D_NO_POSIX_SPAWN"
+        # turn off using cli/sti in i386 setjmp/longjmp
+	newlib_cflags="${newlib_cflags} -D_I386MACH_ALLOW_HW_INTERRUPTS"
+	;;
+# VxWorks supplies its own version of malloc, and the newlib one
+# doesn't work because VxWorks does not have sbrk.
+  *-wrs-vxworks*)
+	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DMISSING_SYSCALL_NAMES -DHAVE_FCNTL"
+	;;
+# TIRTOS supplies its own version of malloc
+  *-*-tirtos*)
+	newlib_cflags="${newlib_cflags} -D__DYNAMIC_REENT__ -DMALLOC_PROVIDED"
+	;;
+# UDI doesn't have exec, so system() should fail the right way
+  a29k-amd-udi)
+	newlib_cflags="${newlib_cflags} -DNO_EXEC"
+	syscall_dir=syscalls
+	;;
+  aarch64*-*-*)
+	default_newlib_io_long_long="yes"
+	syscall_dir=syscalls
+	;;
+  arc*-*-*)
+	syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+	;;
+  arm*-*-pe)
+	syscall_dir=syscalls
+	;;
+  arm*-*-*)
+	syscall_dir=syscalls
+# If newlib is supplying syscalls, select which debug protocol is being used.
+# ARM_RDP_MONITOR selects the Demon monitor.
+# ARM_RDI_MONITOR selects the Angel monitor.
+# If neither are defined, then hard coded defaults will be used
+# to create the program's environment.
+# If --disable-newlib-supplied-syscalls is specified, then the end-user
+# may specify the protocol via gcc spec files supplied by libgloss.
+	if [ "x${newlib_may_supply_syscalls}" = "xyes" ] ; then
+#         newlib_cflags="${newlib_cflags} -DARM_RDP_MONITOR"
+	  newlib_cflags="${newlib_cflags} -DARM_RDI_MONITOR"
+	fi
+	;;
+  avr*)
+	newlib_cflags="${newlib_cflags} -DNO_EXEC -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES"
+	;;
+  bfin*)
+	syscall_dir=syscalls
+	;;
+  cris-*-* | crisv32-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -D_USE_WRITE -DCOMPACT_CTYPE"
+	syscall_dir=syscalls
+	;;
+  cr16-*-*)
+	syscall_dir=syscalls
+	;;
+  crx-*-*)
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  d10v*)
+	newlib_cflags="${newlib_cflags} -DSMALL_MEMORY"
+	syscall_dir=syscalls
+	;;
+  d30v*)
+	newlib_cflags="${newlib_cflags} -DABORT_MESSAGE -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  epiphany*)
+	syscall_dir=syscalls
+	newlib_cflags="${newlib_cflags} -DSIGNAL_PROVIDED"
+	;;
+  fido-*-elf)
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  fr30-*-*)
+	syscall_dir=syscalls
+	;;
+  frv-*-*)
+        syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+        ;;
+  ft32*-*-*)
+        syscall_dir=syscalls
+        ;;
+  h8300*-*-*)
+	syscall_dir=syscalls	
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DSMALL_DTOA -DSMALL_MEMORY"
+	# Simulator only extensions for H8300.
+	# Uncomment the next line to enable them.
+	# newlib_cflags="${newlib_cflags} -D__SIMULATOR__"
+	;;	
+  h8500-*-*)
+	syscall_dir=syscalls	
+	newlib_cflags="${newlib_cflags} -DSMALL_DTOA -DSMALL_MEMORY"
+	;;	
+  i[34567]86-*-sco*)
+	newlib_cflags="${newlib_cflags} -DSIGNAL_PROVIDED -DHAVE_FCNTL"
+	;;
+  i[34567]86-*-netware*)
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES -DNO_EXEC -DABORT_PROVIDED -DCLOCK_PROVIDED -DMALLOC_PROVIDED -DHAVE_FCNTL"
+	;;
+  iq2000*)
+	syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+	;;
+  lm32-*-*)
+	syscall_dir=syscalls
+	;;
+  m32c-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES -DABORT_PROVIDED"
+	syscall_dir=
+  	;;
+  m32r-*-*)
+	# Pass -msdata=sdata so _impure_ptr goes in .sdata.
+	# We don't generate sda relocs however for upward compatibility.
+	# FIXME: This is necessary because the default multilib doesn't
+	# use --print-multi-lib.
+	newlib_cflags="${newlib_cflags} -msdata=sdata"
+	syscall_dir=syscalls
+	;;
+  m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
+	newlib_cflags="${newlib_cflags} -DNO_EXEC -DABORT_PROVIDED -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES"
+	;;
+  m68k-unknown-elf)
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  mcore-*-*)
+	syscall_dir=syscalls
+	;;
+  microblaze*-*-*)
+   	default_newlib_io_long_long="yes"
+ 	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES -DSMALL_MEMORY -D_REENT_SMALL"
+	;;
+  mips64vr*-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  mips*-*-elf*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  mmix-*)
+	syscall_dir=syscalls
+	# We need every symbol 32-bit aligned, so the invalid
+	# construct with attribute ((alias ("_ctype_b+127"))) breaks.
+	newlib_cflags="${newlib_cflags} -DCOMPACT_CTYPE"
+	;;
+  mn10?00-*-*)
+	syscall_dir=syscalls
+	;;
+  moxie-*-elf* | moxie-*-rtems*)
+        syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+        ;;
+  moxie-*-moxiebox)
+        syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -Os -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+        ;;
+  nios2*)
+	syscall_dir=
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	;;
+  nds32*)
+	syscall_dir=syscalls
+	;;
+  or1k*|or1knd*)
+	syscall_dir=syscalls
+	;;
+  powerpc*-*-eabialtivec*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  powerpc*-*-eabispe*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  powerpc*-*-eabi* | \
+  powerpc*-*-elf* | \
+  powerpc*-*-linux* | \
+  powerpc*-*-rtem* | \
+  powerpc*-*-sysv* | \
+  powerpc*-*-solaris*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -mrelocatable-lib -mno-eabi -mstrict-align -DMISSING_SYSCALL_NAMES"
+	;;
+  powerpcle-*-pe)
+	newlib_cflags="${newlib_cflags} -DHAVE_OPENDIR -DHAVE_RENAME -DHAVE_FCNTL -D_NO_POSIX_SPAWN"
+	syscall_dir=syscalls
+	;;
+  sh*-*-*)
+	default_newlib_io_long_long="yes"
+	syscall_dir=syscalls
+	;;
+  sparc-sun-sunos*)
+	newlib_cflags="${newlib_cflags} -DSIGNAL_PROVIDED"
+	;;
+  sparc64-*-*)
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED -DHAVE_BLKSIZE -DHAVE_FCNTL"
+	# This either belongs elsewhere or nowhere. But I need *something*,
+	# so for now it's here ...
+	case "${host_os}" in
+	  aoutv8 | *32p)
+		newlib_cflags="${newlib_cflags} -DTARGET_PTR_SIZE=32" ;;
+	  *)
+		newlib_cflags="${newlib_cflags} -DTARGET_PTR_SIZE=64" ;;
+	esac
+	;;
+  tic6x*)
+	syscall_dir=
+	newlib_cflags="${newlib_cflags} -DCLOCK_PROVIDED"
+	;;
+  tic80*)
+	syscall_dir=syscalls
+	;;
+  v850*-*-*)
+	syscall_dir=syscalls
+	;;
+  visium-*-*)
+	newlib_cflags="${newlib_cflags} -DCLOCK_PROVIDED -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  w65-*-*)
+	syscall_dir=syscalls	
+	newlib_cflags="${newlib_cflags} -DSMALL_DTOA -DSMALL_MEMORY"
+	;;
+  xc16x-*)
+          syscall_dir=syscalls
+        ;;
+  xstormy16-*-*)
+	syscall_dir=syscalls
+	;;
+  z8k-*-*)
+	syscall_dir=syscalls
+	;;
+  *)
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+esac
+
+# Use defaults for certain settings if not specified by user
+
+# Enable C99 format support in I/O routines if requested.
+if [ "x${newlib_io_c99_formats}" = "x" ]; then
+	if [ ${default_newlib_io_c99_formats} = "yes" ]; then
+		newlib_io_c99_formats="yes";
+	fi
+fi
+
+# Enable long long support in I/O routines if requested.
+if [ "x${newlib_io_long_long}" = "x" ]; then
+	if [ ${default_newlib_io_long_long} = "yes" ]; then
+		newlib_io_long_long="yes";
+	fi
+fi
+
+# Enable long double support in I/O routines if requested.
+if [ "x${newlib_io_long_double}" = "x" ]; then
+	if [ ${default_newlib_io_long_double} = "yes" ]; then
+		newlib_io_long_double="yes";
+	fi
+fi
+
+# Enable printf positional argument support if requested.
+if [ "x${newlib_io_pos_args}" = "x" ]; then
+	if [ ${default_newlib_io_pos_args} = "yes" ]; then
+		newlib_io_pos_args="yes";
+	fi
+fi
+
+# Disable atexit dynamic allocation if requested.
+if [ "x${newlib_atexit_dynamic_alloc}" = "x" ]; then
+	if [ ${default_newlib_atexit_dynamic_alloc} = "yes" ]; then
+		newlib_atexit_dynamic_alloc="yes"; 
+	fi
+fi
+
+# Enable nano-malloc if requested.
+if [ "x${newlib_nano_malloc}" = "x" ]; then
+	if [ ${default_newlib_nano_malloc} = "yes" ]; then
+		newlib_nano_malloc="yes";
+	fi
+fi
+
+# Remove rpc headers if xdr_dir not specified
+if [ "x${xdr_dir}" = "x" ]; then
+	noinclude="${noinclude} rpc/types.h rpc/xdr.h"
+fi
+
+if test -z "${have_crt0}" && test -n "${sys_dir}"; then
+  have_crt0="yes"
+fi
diff -ruN newlib-2.4.0/newlib/libc/include/assert.h newlib-2.4.0-kos/newlib/libc/include/assert.h
--- newlib-2.4.0/newlib/libc/include/assert.h	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/include/assert.h	2019-06-11 11:19:48.804253881 +0100
@@ -13,8 +13,8 @@
 #ifdef NDEBUG           /* required by ANSI standard */
 # define assert(__e) ((void)0)
 #else
-# define assert(__e) ((__e) ? (void)0 : __assert_func (__FILE__, __LINE__, \
-						       __ASSERT_FUNC, #__e))
+# define assert(__e) ((__e) ? (void)0 : __assert (__FILE__, __LINE__, \
+						       #__e, (char *)0, __ASSERT_FUNC))
 
 # ifndef __ASSERT_FUNC
   /* Use g++'s demangled names in C++.  */
@@ -36,10 +36,8 @@
 # endif /* !__ASSERT_FUNC */
 #endif /* !NDEBUG */
 
-void _EXFUN(__assert, (const char *, int, const char *)
-	    _ATTRIBUTE ((__noreturn__)));
-void _EXFUN(__assert_func, (const char *, int, const char *, const char *)
-	    _ATTRIBUTE ((__noreturn__)));
+void _EXFUN(__assert, (const char *, int, const char *, const char *,
+                       const char *) _ATTRIBUTE ((__noreturn__)));
 
 #if __STDC_VERSION__ >= 201112L && !defined __cplusplus
 # define static_assert _Static_assert
diff -ruN newlib-2.4.0/newlib/libc/include/machine/_default_types.h newlib-2.4.0-kos/newlib/libc/include/machine/_default_types.h
--- newlib-2.4.0/newlib/libc/include/machine/_default_types.h	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/include/machine/_default_types.h	2019-06-11 11:19:48.804253881 +0100
@@ -7,6 +7,8 @@
 
 #include <sys/features.h>
 
+#include <sys/features.h>
+
 /*
  * Guess on types by examining *_MIN / *_MAX defines.
  */
diff -ruN newlib-2.4.0/newlib/libc/include/machine/_default_types.h.orig newlib-2.4.0-kos/newlib/libc/include/machine/_default_types.h.orig
--- newlib-2.4.0/newlib/libc/include/machine/_default_types.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/include/machine/_default_types.h.orig	2019-06-11 11:19:48.805253881 +0100
@@ -0,0 +1,220 @@
+/*
+ *  $Id$
+ */
+
+#ifndef _MACHINE__DEFAULT_TYPES_H
+#define _MACHINE__DEFAULT_TYPES_H
+
+#include <sys/features.h>
+
+/*
+ * Guess on types by examining *_MIN / *_MAX defines.
+ */
+#if __GNUC_PREREQ (3, 3)
+/* GCC >= 3.3.0 has __<val>__ implicitly defined. */
+#define __EXP(x) __##x##__
+#else
+/* Fall back to POSIX versions from <limits.h> */
+#define __EXP(x) x
+#include <limits.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __INT8_TYPE__
+typedef __INT8_TYPE__ __int8_t;
+#ifdef __UINT8_TYPE__
+typedef __UINT8_TYPE__ __uint8_t;
+#else
+typedef unsigned __INT8_TYPE__ __uint8_t;
+#endif
+#define ___int8_t_defined 1
+#elif __EXP(SCHAR_MAX) == 0x7f
+typedef signed char __int8_t ;
+typedef unsigned char __uint8_t ;
+#define ___int8_t_defined 1
+#endif
+
+#ifdef __INT16_TYPE__
+typedef __INT16_TYPE__ __int16_t;
+#ifdef __UINT16_TYPE__
+typedef __UINT16_TYPE__ __uint16_t;
+#else
+typedef unsigned __INT16_TYPE__ __uint16_t;
+#endif
+#define ___int16_t_defined 1
+#elif __EXP(INT_MAX) == 0x7fff
+typedef signed int __int16_t;
+typedef unsigned int __uint16_t;
+#define ___int16_t_defined 1
+#elif __EXP(SHRT_MAX) == 0x7fff
+typedef signed short __int16_t;
+typedef unsigned short __uint16_t;
+#define ___int16_t_defined 1
+#elif __EXP(SCHAR_MAX) == 0x7fff
+typedef signed char __int16_t;
+typedef unsigned char __uint16_t;
+#define ___int16_t_defined 1
+#endif
+
+#ifdef __INT32_TYPE__
+typedef __INT32_TYPE__ __int32_t;
+#ifdef __UINT32_TYPE__
+typedef __UINT32_TYPE__ __uint32_t;
+#else
+typedef unsigned __INT32_TYPE__ __uint32_t;
+#endif
+#define ___int32_t_defined 1
+#elif __EXP(INT_MAX) == 0x7fffffffL
+typedef signed int __int32_t;
+typedef unsigned int __uint32_t;
+#define ___int32_t_defined 1
+#elif __EXP(LONG_MAX) == 0x7fffffffL
+typedef signed long __int32_t;
+typedef unsigned long __uint32_t;
+#define ___int32_t_defined 1
+#elif __EXP(SHRT_MAX) == 0x7fffffffL
+typedef signed short __int32_t;
+typedef unsigned short __uint32_t;
+#define ___int32_t_defined 1
+#elif __EXP(SCHAR_MAX) == 0x7fffffffL
+typedef signed char __int32_t;
+typedef unsigned char __uint32_t;
+#define ___int32_t_defined 1
+#endif
+
+#ifdef __INT64_TYPE__
+typedef __INT64_TYPE__ __int64_t;
+#ifdef __UINT64_TYPE__
+typedef __UINT64_TYPE__ __uint64_t;
+#else
+typedef unsigned __INT64_TYPE__ __uint64_t;
+#endif
+#define ___int64_t_defined 1
+#elif __EXP(LONG_MAX) > 0x7fffffff
+typedef signed long __int64_t;
+typedef unsigned long __uint64_t;
+#define ___int64_t_defined 1
+
+/* GCC has __LONG_LONG_MAX__ */
+#elif  defined(__LONG_LONG_MAX__) && (__LONG_LONG_MAX__ > 0x7fffffff)
+typedef signed long long __int64_t;
+typedef unsigned long long __uint64_t;
+#define ___int64_t_defined 1
+
+/* POSIX mandates LLONG_MAX in <limits.h> */
+#elif  defined(LLONG_MAX) && (LLONG_MAX > 0x7fffffff)
+typedef signed long long __int64_t;
+typedef unsigned long long __uint64_t;
+#define ___int64_t_defined 1
+
+#elif  __EXP(INT_MAX) > 0x7fffffff
+typedef signed int __int64_t;
+typedef unsigned int __uint64_t;
+#define ___int64_t_defined 1
+#endif
+
+#ifdef __INT_LEAST8_TYPE__
+typedef __INT_LEAST8_TYPE__ __int_least8_t;
+#ifdef __UINT_LEAST8_TYPE__
+typedef __UINT_LEAST8_TYPE__ __uint_least8_t;
+#else
+typedef unsigned __INT_LEAST8_TYPE__ __uint_least8_t;
+#endif
+#define ___int_least8_t_defined 1
+#elif defined(___int8_t_defined)
+typedef __int8_t __int_least8_t;
+typedef __uint8_t __uint_least8_t;
+#define ___int_least8_t_defined 1
+#elif defined(___int16_t_defined)
+typedef __int16_t __int_least8_t;
+typedef __uint16_t __uint_least8_t;
+#define ___int_least8_t_defined 1
+#elif defined(___int32_t_defined)
+typedef __int32_t __int_least8_t;
+typedef __uint32_t __uint_least8_t;
+#define ___int_least8_t_defined 1
+#elif defined(___int64_t_defined)
+typedef __int64_t __int_least8_t;
+typedef __uint64_t __uint_least8_t;
+#define ___int_least8_t_defined 1
+#endif
+
+#ifdef __INT_LEAST16_TYPE__
+typedef __INT_LEAST16_TYPE__ __int_least16_t;
+#ifdef __UINT_LEAST16_TYPE__
+typedef __UINT_LEAST16_TYPE__ __uint_least16_t;
+#else
+typedef unsigned __INT_LEAST16_TYPE__ __uint_least16_t;
+#endif
+#define ___int_least16_t_defined 1
+#elif defined(___int16_t_defined)
+typedef __int16_t __int_least16_t;
+typedef __uint16_t __uint_least16_t;
+#define ___int_least16_t_defined 1
+#elif defined(___int32_t_defined)
+typedef __int32_t __int_least16_t;
+typedef __uint32_t __uint_least16_t;
+#define ___int_least16_t_defined 1
+#elif defined(___int64_t_defined)
+typedef __int64_t __int_least16_t;
+typedef __uint64_t __uint_least16_t;
+#define ___int_least16_t_defined 1
+#endif
+
+#ifdef __INT_LEAST32_TYPE__
+typedef __INT_LEAST32_TYPE__ __int_least32_t;
+#ifdef __UINT_LEAST32_TYPE__
+typedef __UINT_LEAST32_TYPE__ __uint_least32_t;
+#else
+typedef unsigned __INT_LEAST32_TYPE__ __uint_least32_t;
+#endif
+#define ___int_least32_t_defined 1
+#elif defined(___int32_t_defined)
+typedef __int32_t __int_least32_t;
+typedef __uint32_t __uint_least32_t;
+#define ___int_least32_t_defined 1
+#elif defined(___int64_t_defined)
+typedef __int64_t __int_least32_t;
+typedef __uint64_t __uint_least32_t;
+#define ___int_least32_t_defined 1
+#endif
+
+#ifdef __INT_LEAST64_TYPE__
+typedef __INT_LEAST64_TYPE__ __int_least64_t;
+#ifdef __UINT_LEAST64_TYPE__
+typedef __UINT_LEAST64_TYPE__ __uint_least64_t;
+#else
+typedef unsigned __INT_LEAST64_TYPE__ __uint_least64_t;
+#endif
+#define ___int_least64_t_defined 1
+#elif defined(___int64_t_defined)
+typedef __int64_t __int_least64_t;
+typedef __uint64_t __uint_least64_t;
+#define ___int_least64_t_defined 1
+#endif
+
+#ifdef __INTPTR_TYPE__
+typedef __INTPTR_TYPE__ __intptr_t;
+#ifdef __UINTPTR_TYPE__
+typedef __UINTPTR_TYPE__ __uintptr_t;
+#else
+typedef unsigned __INTPTR_TYPE__ __uintptr_t;
+#endif
+#elif defined(__PTRDIFF_TYPE__)
+typedef __PTRDIFF_TYPE__ __intptr_t;
+typedef unsigned __PTRDIFF_TYPE__ __uintptr_t;
+#else
+typedef long __intptr_t;
+typedef unsigned long __uintptr_t;
+#endif
+
+#undef __EXP
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MACHINE__DEFAULT_TYPES_H */
diff -ruN newlib-2.4.0/newlib/libc/include/sys/types.h newlib-2.4.0-kos/newlib/libc/include/sys/types.h
--- newlib-2.4.0/newlib/libc/include/sys/types.h	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/include/sys/types.h	2019-06-11 13:22:22.451030992 +0100
@@ -1,4 +1,4 @@
-/* unified sys/types.h: 
+/* unified sys/types.h:
    start with sef's sysvi386 version.
    merge go32 version -- a few ifdefs.
    h8300hms, h8300xray, and sysvnecv70 disagree on the following types:
@@ -10,8 +10,8 @@
    typedef int mode_t;
    typedef int caddr_t;
 
-   however, these aren't "reasonable" values, the sysvi386 ones make far 
-   more sense, and should work sufficiently well (in particular, h8300 
+   however, these aren't "reasonable" values, the sysvi386 ones make far
+   more sense, and should work sufficiently well (in particular, h8300
    doesn't have a stat, and the necv70 doesn't matter.) -- eichin
  */
 
@@ -29,7 +29,7 @@
 #endif
 #if ___int16_t_defined
 typedef __uint16_t	u_int16_t;
-#endif 
+#endif
 #if ___int32_t_defined
 typedef __uint32_t	u_int32_t;
 #endif
@@ -240,7 +240,7 @@
 
 
 /* Cygwin will probably never have full posix compliance due to little things
- * like an inability to set the stackaddress. Cygwin is also using void *  
+ * like an inability to set the stackaddress. Cygwin is also using void *
  * pointers rather than structs to ensure maximum binary compatability with
  * previous releases.
  * This means that we don't use the types defined here, but rather in
@@ -256,7 +256,7 @@
 
 #if defined(__XMK__)
 typedef unsigned int pthread_t;          /* identify a thread */
-#else
+#elif !defined(_arch_dreamcast)
 typedef __uint32_t pthread_t;            /* identify a thread */
 #endif
 
@@ -278,6 +278,7 @@
   #include <sys/cpuset.h>
 #endif
 
+#if !defined(_arch_dreamcast)
 #if defined(__XMK__)
 typedef struct pthread_attr_s {
   int contentionscope;
@@ -315,6 +316,7 @@
 } pthread_attr_t;
 
 #endif /* !defined(__XMK__) */
+#endif /* !defined(_arch_dreamcast) */
 
 #if defined(_POSIX_THREAD_PROCESS_SHARED)
 /* NOTE: P1003.1c/D10, p. 81 defines following values for process_shared.  */
@@ -362,7 +364,7 @@
  */
 #define PTHREAD_MUTEX_RECURSIVE  1
 
-/* 
+/*
  * This type of mutex provides error checking. A thread attempting
  * to relock this mutex without first unlocking it shall return with an
  * error. A thread attempting to unlock a mutex which another thread has
@@ -391,6 +393,7 @@
 } pthread_mutexattr_t;
 
 #else /* !defined(__XMK__) */
+#if !defined(_arch_dreamcast)
 typedef __uint32_t pthread_mutex_t;      /* identify a mutex */
 
 typedef struct {
@@ -407,10 +410,12 @@
 #endif
   int   recursive;
 } pthread_mutexattr_t;
+#endif /* !defined(_arch_dreamcast) */
 #endif /* !defined(__XMK__) */
 
 /* Condition Variables */
 
+#if !defined(_arch_dreamcast)
 typedef __uint32_t pthread_cond_t;       /* identify a condition variable */
 
 typedef struct {
@@ -420,15 +425,18 @@
   int      process_shared;    /* allow this to be shared amongst processes */
 #endif
 } pthread_condattr_t;         /* a condition attribute object */
+#endif /* !defined(_arch_dreamcast) */
 
 /* Keys */
 
+#if !defined(_arch_dreamcast)
 typedef __uint32_t pthread_key_t;        /* thread-specific data keys */
 
 typedef struct {
   int   is_initialized;  /* is this structure initialized? */
   int   init_executed;   /* has the initialization routine been run? */
 } pthread_once_t;       /* dynamic package initialization */
+#endif /* !defined(_arch_dreamcast) */
 #else
 #if defined (__CYGWIN__)
 #include <cygwin/types.h>
@@ -471,4 +479,6 @@
 
 #undef __need_inttypes
 
+#include <sys/select.h>
+
 #endif	/* _SYS_TYPES_H */
diff -ruN newlib-2.4.0/newlib/libc/include/sys/types.h.orig newlib-2.4.0-kos/newlib/libc/include/sys/types.h.orig
--- newlib-2.4.0/newlib/libc/include/sys/types.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/include/sys/types.h.orig	2019-06-11 11:19:48.805253881 +0100
@@ -0,0 +1,474 @@
+/* unified sys/types.h: 
+   start with sef's sysvi386 version.
+   merge go32 version -- a few ifdefs.
+   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:
+
+   typedef int gid_t;
+   typedef int uid_t;
+   typedef int dev_t;
+   typedef int ino_t;
+   typedef int mode_t;
+   typedef int caddr_t;
+
+   however, these aren't "reasonable" values, the sysvi386 ones make far 
+   more sense, and should work sufficiently well (in particular, h8300 
+   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
+ */
+
+#ifndef _SYS_TYPES_H
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <machine/_types.h>
+
+/* BSD types permitted by POSIX and always exposed as in Glibc.  Only provided
+   for backward compatibility with BSD code.  The uintN_t standard types should
+   be preferred in new code. */
+#if ___int8_t_defined
+typedef __uint8_t	u_int8_t;
+#endif
+#if ___int16_t_defined
+typedef __uint16_t	u_int16_t;
+#endif 
+#if ___int32_t_defined
+typedef __uint32_t	u_int32_t;
+#endif
+#if ___int64_t_defined
+typedef __uint64_t	u_int64_t;
+#endif
+
+#if defined(__rtems__) || defined(__XMK__)
+/*
+ *  The following section is RTEMS specific and is needed to more
+ *  closely match the types defined in the BSD sys/types.h.
+ *  This is needed to let the RTEMS/BSD TCP/IP stack compile.
+ */
+
+/* deprecated */
+#if ___int64_t_defined
+typedef	__uint64_t	u_quad_t;
+typedef	__int64_t	quad_t;
+typedef	quad_t *	qaddr_t;
+#endif
+
+#endif /* __rtems__ || __XMK__ */
+
+#ifndef __need_inttypes
+
+#define _SYS_TYPES_H
+#include <sys/_types.h>
+#include <sys/_stdint.h>
+
+#ifdef __i386__
+#if defined (GO32) || defined (__MSDOS__)
+#define __MS_types__
+#endif
+#endif
+
+# include <stddef.h>
+# include <machine/types.h>
+
+/* To ensure the stat struct's layout doesn't change when sizeof(int), etc.
+   changes, we assume sizeof short and long never change and have all types
+   used to define struct stat use them and not int where possible.
+   Where not possible, _ST_INTxx are used.  It would be preferable to not have
+   such assumptions, but until the extra fluff is necessary, it's avoided.
+   No 64 bit targets use stat yet.  What to do about them is postponed
+   until necessary.  */
+#ifdef __GNUC__
+#define _ST_INT32 __attribute__ ((__mode__ (__SI__)))
+#else
+#define _ST_INT32
+#endif
+
+#if __BSD_VISIBLE
+#include <sys/select.h>
+#  define	physadr		physadr_t
+#  define	quad		quad_t
+#endif
+
+#if __MISC_VISIBLE
+#ifndef _BSDTYPES_DEFINED
+/* also defined in mingw/gmon.h and in w32api/winsock[2].h */
+#ifndef __u_char_defined
+typedef	unsigned char	u_char;
+#define __u_char_defined
+#endif
+#ifndef __u_short_defined
+typedef	unsigned short	u_short;
+#define __u_short_defined
+#endif
+#ifndef __u_int_defined
+typedef	unsigned int	u_int;
+#define __u_int_defined
+#endif
+#ifndef __u_long_defined
+typedef	unsigned long	u_long;
+#define __u_long_defined
+#endif
+#define _BSDTYPES_DEFINED
+#endif
+#endif	/*__BSD_VISIBLE || __CYGWIN__ */
+
+#if __MISC_VISIBLE
+typedef	unsigned short	ushort;		/* System V compatibility */
+typedef	unsigned int	uint;		/* System V compatibility */
+typedef	unsigned long	ulong;		/* System V compatibility */
+#endif
+
+#ifndef __clock_t_defined
+typedef _CLOCK_T_ clock_t;
+#define __clock_t_defined
+#endif
+
+#ifndef __time_t_defined
+typedef _TIME_T_ time_t;
+#define __time_t_defined
+#endif
+
+#ifndef __daddr_t_defined
+typedef	long	daddr_t;
+#define __daddr_t_defined
+#endif
+#ifndef __caddr_t_defined
+typedef	char *	caddr_t;
+#define __caddr_t_defined
+#endif
+
+#ifndef __CYGWIN__
+#if defined(__MS_types__) || defined(__rtems__) || \
+    defined(__sparc__) || defined(__SPU__)
+typedef	unsigned long	ino_t;
+#else
+typedef	unsigned short	ino_t;
+#endif
+#endif /*__CYGWIN__*/
+
+#ifdef __MS_types__
+typedef unsigned long vm_offset_t;
+typedef unsigned long vm_size_t;
+
+#define __BIT_TYPES_DEFINED__
+
+typedef signed char int8_t;
+typedef unsigned char u_int8_t;
+typedef short int16_t;
+typedef unsigned short u_int16_t;
+typedef int int32_t;
+typedef unsigned int u_int32_t;
+typedef long long int64_t;
+typedef unsigned long long u_int64_t;
+typedef int32_t register_t;
+#endif /* __MS_types__ */
+
+/*
+ * All these should be machine specific - right now they are all broken.
+ * However, for all of Cygnus' embedded targets, we want them to all be
+ * the same.  Otherwise things like sizeof (struct stat) might depend on
+ * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
+ */
+
+#ifndef __CYGWIN__	/* which defines these types in it's own types.h. */
+typedef _off_t	off_t;
+typedef __dev_t dev_t;
+typedef __uid_t uid_t;
+typedef __gid_t gid_t;
+#endif
+
+#if defined(__XMK__)
+typedef signed char pid_t;
+#else
+typedef int pid_t;
+#endif
+
+#if defined(__rtems__)
+typedef _mode_t mode_t;
+#endif
+
+#ifndef __CYGWIN__
+typedef	long key_t;
+#endif
+
+#ifndef _SSIZE_T_DECLARED
+typedef _ssize_t ssize_t;
+#define	_SSIZE_T_DECLARED
+#endif
+
+#if !defined(__CYGWIN__) && !defined(__rtems__)
+#ifdef __MS_types__
+typedef	char *	addr_t;
+typedef int mode_t;
+#else
+#if defined (__sparc__) && !defined (__sparc_v9__)
+#ifdef __svr4__
+typedef unsigned long mode_t;
+#else
+typedef unsigned short mode_t;
+#endif
+#else
+typedef unsigned int mode_t _ST_INT32;
+#endif
+#endif /* ! __MS_types__ */
+#endif /*__CYGWIN__*/
+
+typedef unsigned short nlink_t;
+
+#undef __MS_types__
+#undef _ST_INT32
+
+
+#ifndef __clockid_t_defined
+typedef _CLOCKID_T_ clockid_t;
+#define __clockid_t_defined
+#endif
+
+#ifndef __timer_t_defined
+typedef _TIMER_T_ timer_t;
+#define __timer_t_defined
+#endif
+
+typedef unsigned long useconds_t;
+
+#ifndef _SUSECONDS_T_DECLARED
+typedef	__suseconds_t	suseconds_t;
+#define	_SUSECONDS_T_DECLARED
+#endif
+
+typedef	__int64_t	sbintime_t;
+
+#include <sys/features.h>
+
+
+/* Cygwin will probably never have full posix compliance due to little things
+ * like an inability to set the stackaddress. Cygwin is also using void *  
+ * pointers rather than structs to ensure maximum binary compatability with
+ * previous releases.
+ * This means that we don't use the types defined here, but rather in
+ * <cygwin/types.h>
+ */
+#if defined(_POSIX_THREADS) && !defined(__CYGWIN__)
+
+#include <sys/sched.h>
+
+/*
+ *  2.5 Primitive System Data Types,  P1003.1c/D10, p. 19.
+ */
+
+#if defined(__XMK__)
+typedef unsigned int pthread_t;          /* identify a thread */
+#else
+typedef __uint32_t pthread_t;            /* identify a thread */
+#endif
+
+/* P1003.1c/D10, p. 118-119 */
+#define PTHREAD_SCOPE_PROCESS 0
+#define PTHREAD_SCOPE_SYSTEM  1
+
+/* P1003.1c/D10, p. 111 */
+#define PTHREAD_INHERIT_SCHED  1      /* scheduling policy and associated */
+                                      /*   attributes are inherited from */
+                                      /*   the calling thread. */
+#define PTHREAD_EXPLICIT_SCHED 2      /* set from provided attribute object */
+
+/* P1003.1c/D10, p. 141 */
+#define PTHREAD_CREATE_DETACHED 0
+#define PTHREAD_CREATE_JOINABLE  1
+
+#if defined(__rtems__)
+  #include <sys/cpuset.h>
+#endif
+
+#if defined(__XMK__)
+typedef struct pthread_attr_s {
+  int contentionscope;
+  struct sched_param schedparam;
+  int  detachstate;
+  void *stackaddr;
+  size_t stacksize;
+} pthread_attr_t;
+
+#define PTHREAD_STACK_MIN       200
+
+#else /* !defined(__XMK__) */
+typedef struct {
+  int is_initialized;
+  void *stackaddr;
+  int stacksize;
+  int contentionscope;
+  int inheritsched;
+  int schedpolicy;
+  struct sched_param schedparam;
+#if defined(__rtems__)
+  size_t guardsize;
+#endif
+
+  /* P1003.4b/D8, p. 54 adds cputime_clock_allowed attribute.  */
+#if defined(_POSIX_THREAD_CPUTIME)
+  int  cputime_clock_allowed;  /* see time.h */
+#endif
+  int  detachstate;
+#if defined(__rtems__)
+  size_t affinitysetsize;
+  cpu_set_t *affinityset;
+  cpu_set_t affinitysetpreallocated;
+#endif
+} pthread_attr_t;
+
+#endif /* !defined(__XMK__) */
+
+#if defined(_POSIX_THREAD_PROCESS_SHARED)
+/* NOTE: P1003.1c/D10, p. 81 defines following values for process_shared.  */
+
+#define PTHREAD_PROCESS_PRIVATE 0 /* visible within only the creating process */
+#define PTHREAD_PROCESS_SHARED  1 /* visible too all processes with access to */
+                                  /*   the memory where the resource is */
+                                  /*   located */
+#endif
+
+#if defined(_POSIX_THREAD_PRIO_PROTECT)
+/* Mutexes */
+
+/* Values for blocking protocol. */
+
+#define PTHREAD_PRIO_NONE    0
+#define PTHREAD_PRIO_INHERIT 1
+#define PTHREAD_PRIO_PROTECT 2
+#endif
+
+#if defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES)
+
+/* Values for mutex type */
+
+/* The following defines are part of the X/Open System Interface (XSI). */
+
+/*
+ * This type of mutex does not detect deadlock. A thread attempting to
+ * relock this mutex without first unlocking it shall deadlock. Attempting
+ * to unlock a mutex locked by a different thread results in undefined
+ * behavior.  Attempting to unlock an unlocked mutex results in undefined
+ * behavior.
+ */
+#define PTHREAD_MUTEX_NORMAL     0
+
+/*
+ * A thread attempting to relock this mutex without first unlocking
+ * it shall succeed in locking the mutex.  The relocking deadlock which
+ * can occur with mutexes of type PTHREAD_MUTEX_NORMAL cannot occur with
+ * this type of mutex.  Multiple locks of this mutex shall require the
+ * same number of unlocks to release the mutex before another thread can
+ * acquire the mutex. A thread attempting to unlock a mutex which another
+ * thread has locked shall return with an error.  A thread attempting to
+ * unlock an unlocked mutex shall return with an error.
+ */
+#define PTHREAD_MUTEX_RECURSIVE  1
+
+/* 
+ * This type of mutex provides error checking. A thread attempting
+ * to relock this mutex without first unlocking it shall return with an
+ * error. A thread attempting to unlock a mutex which another thread has
+ * locked shall return with an error. A thread attempting to unlock an
+ * unlocked mutex shall return with an error.
+ */
+#define PTHREAD_MUTEX_ERRORCHECK 2
+
+/*
+ * Attempting to recursively lock a mutex of this type results
+ * in undefined behavior. Attempting to unlock a mutex of this type
+ * which was not locked by the calling thread results in undefined
+ * behavior. Attempting to unlock a mutex of this type which is not locked
+ * results in undefined behavior. An implementation may map this mutex to
+ * one of the other mutex types.
+ */
+#define PTHREAD_MUTEX_DEFAULT    3
+
+#endif /* !defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES) */
+
+#if defined(__XMK__)
+typedef unsigned int pthread_mutex_t;    /* identify a mutex */
+
+typedef struct {
+  int type;
+} pthread_mutexattr_t;
+
+#else /* !defined(__XMK__) */
+typedef __uint32_t pthread_mutex_t;      /* identify a mutex */
+
+typedef struct {
+  int   is_initialized;
+#if defined(_POSIX_THREAD_PROCESS_SHARED)
+  int   process_shared;  /* allow mutex to be shared amongst processes */
+#endif
+#if defined(_POSIX_THREAD_PRIO_PROTECT)
+  int   prio_ceiling;
+  int   protocol;
+#endif
+#if defined(_UNIX98_THREAD_MUTEX_ATTRIBUTES)
+  int type;
+#endif
+  int   recursive;
+} pthread_mutexattr_t;
+#endif /* !defined(__XMK__) */
+
+/* Condition Variables */
+
+typedef __uint32_t pthread_cond_t;       /* identify a condition variable */
+
+typedef struct {
+  int      is_initialized;
+  clock_t  clock;             /* specifiy clock for timeouts */
+#if defined(_POSIX_THREAD_PROCESS_SHARED)
+  int      process_shared;    /* allow this to be shared amongst processes */
+#endif
+} pthread_condattr_t;         /* a condition attribute object */
+
+/* Keys */
+
+typedef __uint32_t pthread_key_t;        /* thread-specific data keys */
+
+typedef struct {
+  int   is_initialized;  /* is this structure initialized? */
+  int   init_executed;   /* has the initialization routine been run? */
+} pthread_once_t;       /* dynamic package initialization */
+#else
+#if defined (__CYGWIN__)
+#include <cygwin/types.h>
+#endif
+#endif /* defined(_POSIX_THREADS) */
+
+/* POSIX Barrier Types */
+
+#if !defined(__CYGWIN__)
+#if defined(_POSIX_BARRIERS)
+typedef __uint32_t pthread_barrier_t;        /* POSIX Barrier Object */
+typedef struct {
+  int   is_initialized;  /* is this structure initialized? */
+#if defined(_POSIX_THREAD_PROCESS_SHARED)
+  int   process_shared;       /* allow this to be shared amongst processes */
+#endif
+} pthread_barrierattr_t;
+#endif /* defined(_POSIX_BARRIERS) */
+
+/* POSIX Spin Lock Types */
+
+#if defined(_POSIX_SPIN_LOCKS)
+typedef __uint32_t pthread_spinlock_t;        /* POSIX Spin Lock Object */
+#endif /* defined(_POSIX_SPIN_LOCKS) */
+
+/* POSIX Reader/Writer Lock Types */
+
+#if defined(_POSIX_READER_WRITER_LOCKS)
+typedef __uint32_t pthread_rwlock_t;         /* POSIX RWLock Object */
+typedef struct {
+  int   is_initialized;       /* is this structure initialized? */
+#if defined(_POSIX_THREAD_PROCESS_SHARED)
+  int   process_shared;       /* allow this to be shared amongst processes */
+#endif
+} pthread_rwlockattr_t;
+#endif /* defined(_POSIX_READER_WRITER_LOCKS) */
+#endif /* __CYGWIN__ */
+
+#endif  /* !__need_inttypes */
+
+#undef __need_inttypes
+
+#endif	/* _SYS_TYPES_H */
diff -ruN newlib-2.4.0/newlib/libc/stdlib/assert.c newlib-2.4.0-kos/newlib/libc/stdlib/assert.c
--- newlib-2.4.0/newlib/libc/stdlib/assert.c	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/stdlib/assert.c	2019-06-11 11:19:48.805253881 +0100
@@ -47,6 +47,8 @@
 #include <stdlib.h>
 #include <stdio.h>
 
+#if 0
+
 #ifndef HAVE_ASSERT_FUNC
 /* func can be NULL, in which case no function information is given.  */
 void
@@ -74,3 +76,4 @@
    __assert_func (file, line, NULL, failedexpr);
   /* NOTREACHED */
 }
+#endif
diff -ruN newlib-2.4.0/newlib/libc/sys/sh/ftruncate.c newlib-2.4.0-kos/newlib/libc/sys/sh/ftruncate.c
--- newlib-2.4.0/newlib/libc/sys/sh/ftruncate.c	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/sys/sh/ftruncate.c	2019-06-11 11:19:48.806253881 +0100
@@ -1,9 +1 @@
-#include <_ansi.h>
-#include <sys/types.h>
-#include "sys/syscall.h"
-
-int
-ftruncate (int file, off_t length)
-{
-  return __trap34 (SYS_ftruncate, file, length, 0);
-}
+/* Nothing here. */
diff -ruN newlib-2.4.0/newlib/libc/sys/sh/sys/lock.h newlib-2.4.0-kos/newlib/libc/sys/sh/sys/lock.h
--- newlib-2.4.0/newlib/libc/sys/sh/sys/lock.h	1970-01-01 01:00:00.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/sys/sh/sys/lock.h	2019-06-11 11:19:48.806253881 +0100
@@ -0,0 +1,51 @@
+/* KallistiOS ##version##
+
+   lock_common.h
+   Copyright (C)2004 Dan Potter
+
+*/
+
+#ifndef __SYS_LOCK_H__
+#define __SYS_LOCK_H__
+
+typedef struct {
+	void	* owner;
+	int	nest;
+	volatile int lock;
+} __newlib_recursive_lock_t;
+
+#define __NEWLIB_RECURSIVE_LOCK_INIT { (void *)0, 0, 0 }
+
+typedef volatile int __newlib_lock_t;
+#define __NEWLIB_LOCK_INIT 0
+
+typedef __newlib_lock_t _LOCK_T;
+typedef __newlib_recursive_lock_t _LOCK_RECURSIVE_T;
+
+#define __LOCK_INIT(class,lock) class _LOCK_T lock = __NEWLIB_LOCK_INIT;
+#define __LOCK_INIT_RECURSIVE(class,lock) class _LOCK_RECURSIVE_T lock = __NEWLIB_RECURSIVE_LOCK_INIT;
+#define __lock_init(lock) __newlib_lock_init(&(lock))
+#define __lock_init_recursive(lock) __newlib_lock_init_recursive(&(lock))
+#define __lock_close(lock) __newlib_lock_close(&(lock))
+#define __lock_close_recursive(lock) __newlib_lock_close_recursive(&(lock))
+#define __lock_acquire(lock) __newlib_lock_acquire(&(lock))
+#define __lock_acquire_recursive(lock) __newlib_lock_acquire_recursive(&(lock))
+#define __lock_try_acquire(lock) __newlib_lock_try_acquire(&(lock))
+#define __lock_try_acquire_recursive(lock) __newlib_lock_try_acquire_recursive(&(lock))
+#define __lock_release(lock) __newlib_lock_release(&(lock))
+#define __lock_release_recursive(lock) __newlib_lock_release_recursive(&(lock))
+
+void __newlib_lock_init(__newlib_lock_t *);
+void __newlib_lock_close(__newlib_lock_t *);
+void __newlib_lock_acquire(__newlib_lock_t *);
+void __newlib_lock_try_acquire(__newlib_lock_t *);
+void __newlib_lock_release(__newlib_lock_t *);
+
+void __newlib_lock_init_recursive(__newlib_recursive_lock_t *);
+void __newlib_lock_close_recursive(__newlib_recursive_lock_t *);
+void __newlib_lock_acquire_recursive(__newlib_recursive_lock_t *);
+void __newlib_lock_try_acquire_recursive(__newlib_recursive_lock_t *);
+void __newlib_lock_release_recursive(__newlib_recursive_lock_t *);
+
+
+#endif // __NEWLIB_LOCK_COMMON_H
diff -ruN newlib-2.4.0/newlib/libc/sys/sh/syscalls.c newlib-2.4.0-kos/newlib/libc/sys/sh/syscalls.c
--- newlib-2.4.0/newlib/libc/sys/sh/syscalls.c	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/sys/sh/syscalls.c	2019-06-11 11:19:48.806253881 +0100
@@ -1,228 +1,2 @@
-#include <_ansi.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-#include "sys/syscall.h"
-int errno;
-
-/* This is used by _sbrk.  */
-register char *stack_ptr asm ("r15");
-
-int
-_read (int file,
-       char *ptr,
-       int len)
-{
-  return __trap34 (SYS_read, file, ptr, len);
-}
-
-int
-_lseek (int file,
-	int ptr,
-	int dir)
-{
-  return __trap34 (SYS_lseek, file, ptr, dir);
-}
-
-int
-_write ( int file,
-	 char *ptr,
-	 int len)
-{
-  return __trap34 (SYS_write, file, ptr, len);
-}
-
-int
-_close (int file)
-{
-  return __trap34 (SYS_close, file, 0, 0);
-}
-
-int
-_link (char *old, char *new)
-{
-  return -1;
-}
-
-caddr_t
-_sbrk (int incr)
-{
-  extern char end;		/* Defined by the linker */
-  static char *heap_end;
-  char *prev_heap_end;
-
-  if (heap_end == 0)
-    {
-      heap_end = &end;
-    }
-  prev_heap_end = heap_end;
-  if (heap_end + incr > stack_ptr)
-    {
-      _write (1, "Heap and stack collision\n", 25);
-      abort ();
-    }
-  heap_end += incr;
-  return (caddr_t) prev_heap_end;
-}
-
-int
-_fstat (int file,
-	struct stat *st)
-{
-  st->st_mode = S_IFCHR;
-  return 0;
-}
-
-int
-_open (const char *path,
-	int flags)
-{
-  return __trap34 (SYS_open, path, flags, 0);
-}
-
-int
-_creat (const char *path,
-	int mode)
-{
-  return __trap34 (SYS_creat, path, mode, 0);
-}
-
-int
-_unlink ()
-{
-  return -1;
-}
-
-isatty (fd)
-     int fd;
-{
-  return 1;
-}
-
-_isatty (fd)
-     int fd;
-{
-  return 1;
-}
-
-
-_exit (n)
-{
-  return __trap34 (SYS_exit, n, 0, 0);
-}
-
-_kill (n, m)
-{
-  return __trap34 (SYS_exit, 0xdead, 0, 0);
-}
-
-_getpid (n)
-{
-  return 1;
-}
-
-_raise ()
-{
-}
-
-int
-_stat (const char *path, struct stat *st)
-
-{
-  return __trap34 (SYS_stat, path, st, 0);
-}
-
-int
-_chmod (const char *path, short mode)
-{
-  return __trap34 (SYS_chmod, path, mode);
-}
-
-int
-_chown (const char *path, short owner, short group)
-{
-  return __trap34 (SYS_chown, path, owner, group);
-}
-
-int
-_utime (path, times)
-     const char *path;
-     char *times;
-{
-  return __trap34 (SYS_utime, path, times);
-}
-
-int
-_fork ()
-{
-  return __trap34 (SYS_fork);
-}
-
-int
-_wait (statusp)
-     int *statusp;
-{
-  return __trap34 (SYS_wait);
-}
-
-int
-_execve (const char *path, char *const argv[], char *const envp[])
-{
-  return __trap34 (SYS_execve, path, argv, envp);
-}
-
-int
-_execv (const char *path, char *const argv[])
-{
-  return __trap34 (SYS_execv, path, argv);
-}
-
-int
-_pipe (int *fd)
-{
-  return __trap34 (SYS_pipe, fd);
-}
-
-/* This is only provided because _gettimeofday_r and _times_r are
-   defined in the same module, so we avoid a link error.  */
-clock_t
-_times (struct tms *tp)
-{
-  return -1;
-}
-
-int
-_gettimeofday (struct timeval *tv, void *tz)
-{
-  tv->tv_usec = 0;
-  tv->tv_sec = __trap34 (SYS_time);
-  return 0;
-}
-
-static inline int
-__setup_argv_for_main (int argc)
-{
-  char **argv;
-  int i = argc;
-
-  argv = __builtin_alloca ((1 + argc) * sizeof (*argv));
-
-  argv[i] = NULL;
-  while (i--) {
-    argv[i] = __builtin_alloca (1 + __trap34 (SYS_argnlen, i));
-    __trap34 (SYS_argn, i, argv[i]);
-  }
-
-  return main (argc, argv);
-}
-
-int
-__setup_argv_and_call_main ()
-{
-  int argc = __trap34 (SYS_argc);
-
-  if (argc <= 0)
-    return main (argc, NULL);
-  else
-    return __setup_argv_for_main (argc);
-}
+// This is put in here to cause link errors if a proper newlib isn't present.
+int __newlib_kos_patch = 1;
diff -ruN newlib-2.4.0/newlib/libc/sys/sh/trap.S newlib-2.4.0-kos/newlib/libc/sys/sh/trap.S
--- newlib-2.4.0/newlib/libc/sys/sh/trap.S	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/sys/sh/trap.S	2019-06-11 11:19:48.806253881 +0100
@@ -1,43 +0,0 @@
-#if __SH5__
-	.mode	SHmedia
-#if __SH5__ == 32 && __SHMEDIA__
-	.section	.text..SHmedia32, "ax"
-#else
-	.text
-#endif
-	.global ___trap34
-___trap34:
-	movi	34, r0
-	trapa	r0
-	pt/l	ret, tr1
-	ptabs/l	r18, tr0
-	beqi	r1, 0, tr1
-#if __SH5__ == 64
-	movi	((_errno >> 48) & 65535), r0
-	shori	((_errno >> 32) & 65535), r0
-	shori	((_errno >> 16) & 65535), r0
-#else
-	movi	((_errno >> 16) & 65535), r0
-#endif
-	shori	(_errno & 65535), r0
-	stx.l	r0, r63, r1
-ret:
-	blink	tr0, r63
-	
-#else
-	.text
-	.global	___trap34
-___trap34:
-	trapa	#34
-	tst	r1,r1	! r1 is errno
-	bt	ret
-	mov.l	perrno,r2
-	mov.l	r1,@r2
-ret:
-	rts
-	nop
-	
-	.align	2
-perrno:
-	.long	_errno
-#endif /* ! __SH5__ */
diff -ruN newlib-2.4.0/newlib/libc/sys/sh/truncate.c newlib-2.4.0-kos/newlib/libc/sys/sh/truncate.c
--- newlib-2.4.0/newlib/libc/sys/sh/truncate.c	2016-03-29 22:33:42.000000000 +0100
+++ newlib-2.4.0-kos/newlib/libc/sys/sh/truncate.c	2019-06-11 11:19:48.806253881 +0100
@@ -1,9 +1 @@
-#include <_ansi.h>
-#include <sys/types.h>
-#include "sys/syscall.h"
-
-int
-truncate (const char *path, off_t length)
-{
-  return __trap34 (SYS_truncate, path, length, 0);
-}
+/* Nothing here. */
